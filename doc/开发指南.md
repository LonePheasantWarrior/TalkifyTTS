# Talkify 开发指南

## 目录

1. [项目描述](#项目描述)
2. [技术栈](#技术栈)
3. [项目架构](#项目架构)
4. [配置存储架构](#配置存储架构)
5. [代码规范](#代码规范)
6. [国际化](#国际化)
7. [资源文件](#资源文件)
8. [已实现功能](#已实现功能)
9. [日志与错误处理](#日志与错误处理)
10. [语音预览功能](#10-语音预览功能demo-service)
11. [请求队列与速率控制](#11-请求队列与速率控制)
12. [架构优化与近期修复](#12-架构优化与近期修复)
13. [开发规范补充](#13-开发规范补充)
14. [启动网络检查功能](#14-启动网络检查功能)
15. [错误处理改进](#15-错误处理改进)
16. [兼容模式功能](#16-兼容模式功能)
17. [通知权限请求功能](#17-通知权限请求功能)

---

## 项目描述

1. 由云端大模型驱动的安卓语音合成应用。
2. 通过接入云提供商的基于 AI 的 TTS 在线服务来实现语音合成功能。
3. 计划允许接入多个云服务商的在线 TTS 服务，实现软件内切换合成引擎。
4. 安卓原生 UI 风格（Material 3 Expressive）。
5. 基于接口的解耦设计，以便后续接入更多语音引擎（TTS 在线服务）。

## 技术栈

本项目采用现代 Android 开发技术栈：

- **语言**：Kotlin
- **UI 框架**：Jetpack Compose + Material 3 Expressive
- **最低 SDK**：30（Android 11）
- **目标 SDK**：36
- **构建工具**：Gradle 8.13 + AGP 8.13.2

## 项目架构

项目采用分层架构设计，实现了清晰的职责分离：

```
app/src/main/java/com/github/lonepheasantwarrior/talkify/
├── MainActivity.kt              # 应用入口，Compose UI 启动点
├── TalkifyApplication.kt        # Application 类（全局异常处理初始化 + 通知通道预创建）
├── TalkifyNotificationActivity.kt # 全屏通知弹窗 Activity（heads-up 悬浮通知）
├── TalkifyCheckDataActivity.kt  # TTS 数据检查 Activity（系统 TTS 集成）
├── TalkifySampleTextActivity.kt # 采样文本 Activity（系统 TTS 集成）
├── GlobalException.kt           # 全局异常处理器和应用上下文持有者
├── domain/                            # 领域层（业务逻辑核心）
│   ├── model/
│   │   ├── TtsModels.kt               # TTS 引擎领域模型
│   │   ├── EngineConfig.kt            # 引擎配置数据类（apiKey, voiceId）
│   │   ├── ConfigItem.kt              # 配置项数据类
│   │   ├── EngineIds.kt               # 引擎 ID 密封类（类型安全的引擎标识）
│   │   ├── TtsEngineRegistry.kt       # 引擎注册表（单一数据源管理模式）
│   │   ├── UpdateInfo.kt              # 更新信息数据类
│   │   └── UpdateCheckResult.kt       # 更新检查结果密封类
│   └── repository/
│       ├── VoiceRepository.kt         # 声音仓储接口
│       ├── EngineConfigRepository.kt  # 引擎配置仓储接口
│       └── AppConfigRepository.kt     # 应用配置仓储接口（全局配置）
├── infrastructure/                    # 基础设施层（外部服务集成）
│   ├── engine/                        # 引擎特定实现
│   │   └── repo/
│   │       ├── Qwen3TtsVoiceRepository.kt   # 通义千问3语音仓储实现
│   │       └── Qwen3TtsConfigRepository.kt  # 通义千问3配置仓储实现（SharedPreferences）
│   └── app/                           # 应用级全局配置实现
│       ├── permission/
│       │   ├── PermissionChecker.kt         # 权限检查工具类
│       │   ├── NetworkConnectivityChecker.kt # 网络连通性检查工具类（统一入口）
│       │   └── ConnectivityMonitor.kt       # 网络状态监控器
│       ├── notification/
│       │   ├── TalkifyNotificationHelper.kt # 快捷通知发送 Helper
│       │   ├── NotificationHelper.kt        # 底层通知构建与发送
│       │   └── NotificationModels.kt        # 通知通道枚举与数据模型
│       ├── update/
│       │   └── UpdateChecker.kt             # GitHub Releases API 调用与更新检查
│       └── repo/
│           └── SharedPreferencesAppConfigRepository.kt # 应用配置仓储实现（全局配置，SharedPreferences）
├── service/                           # 服务层（TTS 引擎服务）
│   ├── TalkifyTtsService.kt           # TTS 服务实现（继承 TextToSpeechService）
│   ├── TalkifyTtsDemoService.kt       # TTS 演示服务（语音预览功能）
│   ├── CompatibilityModePlayer.kt     # 兼容模式专用播放器
│   ├── TtsAudioPlayer.kt              # 内置音频播放器（流式播放 + 进度回调）
│   ├── TtsErrorCode.kt                # 错误码定义（15种错误类型，含网络错误）
│   ├── TtsErrorHelper.kt              # 错误处理助手（Toast提示、错误冷却）
│   ├── TtsLogger.kt                   # 日志工具类（支持多级别日志）
│   └── engine/
│       ├── TtsEngineApi.kt            # 引擎抽象接口（含 TtsSynthesisListener、SynthesisParams）
│       ├── AbstractTtsEngine.kt       # 引擎抽象基类（含日志工具方法）
│       ├── AudioConfig.kt             # 引擎音频配置类
│       ├── TtsStreamHandler.kt        # 流式处理接口（可扩展）
│       ├── TtsEngineFactory.kt        # 引擎工厂（线程安全、支持动态注册）
│       └── impl/
│           └── Qwen3TtsEngine.kt      # 通义千问3引擎实现（DashScope SDK 流式合成）
├── ui/                                # 表现层（UI 组件）
│   ├── components/
│   │   ├── EngineSelector.kt          # 引擎切换控件
│   │   ├── VoicePreview.kt            # 语音预览控件
│   │   ├── ConfigEditor.kt            # 配置编辑表单
│   │   ├── ConfigBottomSheet.kt       # 底部设置弹窗
│   │   ├── UpdateDialog.kt            # 更新提示对话框
│   │   ├── PermissionDialog.kt        # 权限请求对话框（联网权限）
│   │   ├── NetworkBlockedDialog.kt    # 网络阻塞对话框
│   │   ├── NotificationPermissionDialog.kt # 通知权限请求弹窗
│   │   └── MarkdownText.kt            # Markdown 文本组件
│   ├── screens/
│   │   └── MainScreen.kt              # 主界面
│   └── theme/                         # 主题配置
│       ├── Color.kt                   # 颜色定义
│       ├── Theme.kt                   # 主题配置
│       └── Type.kt                    # 字体排版
└── util/                              # 工具类（可选）
    └── TalkifyAudioPlayer.kt          # 音频播放器工具类
```

### 分层架构说明

**领域层（domain）** 包含核心业务模型和接口定义：

| 类/接口 | 类型 | 说明 |
|--------|------|------|
| `TtsEngine` | 数据类 | TTS 引擎基本信息（id, name, provider） |
| `EngineConfig` | 数据类 | 引擎配置（apiKey, voiceId） |
| `ConfigItem` | 数据类 | 配置项（支持密码/语音选择模式） |
| `EngineIds` | 密封类 | 类型安全的引擎 ID 定义 |
| `TtsEngineRegistry` | 单例 | 引擎注册表（可用引擎列表管理） |
| `VoiceRepository` | 接口 | 声音列表获取标准方法 |
| `EngineConfigRepository` | 接口 | 引擎配置存取标准方法 |
| `AppConfigRepository` | 接口 | 全局配置存取标准方法 |

**引擎 ID 设计原则**：
- 直接采用云服务提供商的官方产品标识符
- 示例：`qwen3-tts`（阿里云通义千问3语音合成服务）
- 便于 API 调用对接，减少映射转换

**基础设施层（infrastructure）** 负责外部服务集成和数据获取：

**engine/ 目录 - 引擎特定实现**：
- `Qwen3TtsVoiceRepository`：从资源文件加载声音列表
- `Qwen3TtsConfigRepository`：使用 SharedPreferences 持久化引擎配置
  - 按引擎 ID 隔离存储不同引擎的配置
  - 存储位置：`talkify_engine_configs.xml`

**app/ 目录 - 应用级全局配置实现**：
- `SharedPreferencesAppConfigRepository`：应用配置仓储实现
  - 存储应用级全局配置：selected_engine（用户选择的引擎 ID）
  - 与引擎特定配置分离，不与任何特定 TTS 引擎绑定
  - 存储位置：`talkify_app_config.xml`

**notification/ 目录 - 通知系统**：
- `TalkifyNotificationChannel`：通知通道枚举
  - `TTS_PLAYBACK`：朗读服务通知通道（ IMPORTANCE_LOW ）
  - `SYSTEM_NOTIFICATION`：系统通知通道（ IMPORTANCE_HIGH ，支持 heads-up 悬浮通知）
  - 提供 `fromChannelId()` 方法根据 Channel ID 查找枚举值

- `NotificationModels`：通知数据模型
  - `NotificationContent`：通知内容（标题、文本、图标资源 ID）
  - `NotificationOptions`：通知选项（通道、ID、内容、Intent、优先级、全屏 Intent 等）

- `NotificationHelper`：底层通知构建与发送工具
  - `createNotificationChannel()`：创建通知通道
  - `buildNotification()`：构建通知对象
  - `sendNotification()`：发送通知
  - `cancelNotification()`：取消通知

- `TalkifyNotificationHelper`：快捷通知发送 Helper
  - `sendTtsPlaybackNotification()`：发送 TTS 朗读通知
  - `sendSystemNotification()`：发送系统级重要通知
    - 支持自定义通知内容和可选的通知 ID、优先级及全屏 Intent
    - 高优先级通知会显示为 heads-up 悬浮通知
    - 默认 priority 为 PRIORITY_HIGH
  - `buildForegroundWithNotification()`：构建前台服务通知
  - `cancelTtsPlaybackNotification()`：取消 TTS 朗读通知

**update/ 目录 - 更新检查**：
- `UpdateChecker`：GitHub Releases API 调用与更新检查
  - `checkForUpdate()`：检查应用更新
  - 使用 GitHub Releases API 获取最新版本信息
  - 支持 Release Notes 获取和展示
  - 智能处理 API 错误和网络异常
  - 提供 `UpdateCheckResult` 结果类型（UpdateAvailable、NoUpdate、Error）

**permission/ 目录 - 权限与网络检查**：
- `PermissionChecker`：运行时权限检查工具类
  - `hasInternetPermission()`：检查联网权限
  - `hasNotificationPermission()`：检查通知权限（Android 13+）
  - `getMissingPermissions()`：获取缺失的权限列表
  - 兼容 Android 13+ 运行时权限模型
- `NetworkConnectivityChecker`：网络连通性检查（统一入口）
  - 单例模式，提供全局网络状态查询
  - `isNetworkAvailable()`：检查网络是否可用
  - `isBlockedByNetworkPolicy()`：检查是否被系统网络策略阻止
  - 自动处理不同 Android 版本的权限和 API 差异
- `ConnectivityMonitor`：网络状态监控器
  - `startMonitoring()`：开始监控网络状态变化
  - `stopMonitoring()`：停止监控
  - `testTcpConnectivity()`：测试 TCP 连接（直连 Google/GitHub）
  - 使用 `BroadcastReceiver` 监听网络变化
  - 多地址 TCP 连接测试，提高检测准确性

**服务层（service）** 负责 TTS 引擎服务集成：

**TtsLogger 日志工具**：
- 提供统一的日志打印功能，支持多级别（d/i/w/e/v）
- 支持 Debug 日志开关控制（Release 版本可禁用）
- 支持延迟求值的日志消息（减少不必要的字符串拼接）
- 线程安全，使用 `@Volatile` 和 `synchronized`

**TtsErrorCode 错误码**：
- 定义多种错误类型，提供错误码到用户友好消息的映射
- 提供错误码到 Android TTS 错误码的转换
- **详细错误码列表和错误处理机制请参阅**[第 15 章](#15-错误处理改进)

**TtsErrorHelper 错误处理助手**：
- 提供用户友好的 Toast 错误提示
- 错误冷却机制（3秒内不重复显示相同错误）
- 配置错误建议操作提示

**TalkifyTtsService**：
- 继承 `android.speech.tts.TextToSpeechService`
- 实现系统 TTS 框架与本应用引擎之间的桥梁
- 通过 `AppConfigRepository` 获取用户选择的引擎 ID
- 通过 `EngineConfigRepository` 获取引擎配置
- 使用 `TtsEngineFactory` 创建对应的引擎实例
- 委托引擎执行实际的语音合成
- 完整的异常处理和错误通知机制
- **详细功能说明**：请求队列、速率控制、优雅关闭机制请参阅[第 11 章](#11-请求队列与速率控制)

**TalkifyTtsDemoService**：
- 继承 `android.speech.tts.TextToSpeechService`
- 用于语音预览功能的独立 TTS 服务
- 与主服务分离，避免干扰正常的 TTS 请求处理
- 复用引擎实现，支持预览时的语音合成

**CompatibilityModePlayer**：
- 兼容模式专用音频播放器
- 同步播放模式，音频播放完成后再返回
- 适配未完全遵守 Android TTS 调用规范的阅读软件
- 支持 AudioTrack 直接播放 PCM 音频数据
- 提供播放进度回调和完成通知

**TtsAudioPlayer**：
- 内置音频播放器（流式播放 + 进度回调）
- 用于 TTS 引擎音频流的播放
- 支持流式接收和播放，减少延迟
- 提供播放进度和完成状态回调
- 自动处理音频格式转换

**TtsErrorHelper 错误处理助手**：
- 提供用户友好的 Toast 错误提示
- 错误冷却机制（3秒内不重复显示相同错误）
- 配置错误建议操作提示
- 单例模式，确保全局唯一的错误提示行为

**service/engine/ 目录 - 引擎抽象层**：
- `TtsEngineApi`：引擎抽象接口，定义引擎必须实现的核心方法
  - `synthesize()`：合成语音（支持 SynthesisParams 参数）
  - `stop()`：停止合成
  - `release()`：释放资源
  - `SynthesisParams`：合成参数数据类（pitch、speechRate、volume、language）
- `TtsSynthesisListener`：合成监听器接口（定义于 TtsEngineApi.kt）
  - `onSynthesisStarted()`：合成开始回调
  - `onAudioAvailable()`：音频数据可用（流式传输）
  - `onSynthesisCompleted()`：合成完成回调
  - `onError()`：错误回调
- `AudioConfig`：引擎音频配置类
  - 封装引擎特定的音频参数（采样率、音频格式、声道数）
  - 提供默认配置和引擎特定配置
  - `AudioConfig.QWEN3_TTS`：通义千问3默认配置（24000Hz、PCM_16BIT、单声道）
- `TtsStreamHandler`：流式处理接口（可扩展）
- `AbstractTtsEngine`：引擎抽象基类，提供共性功能的默认实现
  - `isConfigured()`：检查引擎是否已配置（检查 API Key）
  - `stop()`：停止合成（空实现）
  - `release()`：释放资源，设置释放标志
  - `checkNotReleased()`：检查引擎是否已释放，未释放则抛异常
  - 日志工具方法：`logDebug()`、`logInfo()`、`logWarning()`、`logError()`
- `TtsEngineFactory`：引擎工厂，根据引擎 ID 创建对应的引擎实例
  - 线程安全：双重检查锁定的单例模式
  - 支持引擎热插拔，新增引擎只需在此注册
  - `createEngine(id)`：根据 ID 创建引擎实例
  - `isRegistered(id)`：检查引擎是否已注册
  - `getAllEngineInfo()`：获取所有注册引擎信息
  - `registerEngine()`、`unregisterEngine()`：动态注册/注销引擎（用于测试）

**service/engine/impl/ 目录 - 引擎具体实现**：
- `Qwen3TtsEngine`：通义千问3引擎实现
  - 继承 `AbstractTtsEngine`
  - 实现 DashScope SDK 流式语音合成
  - 引擎 ID：`qwen3-tts`
  - **动态声音选择**：使用 `parseVoice()` 方法将用户配置的声音 ID 转换为 `AudioParameters.Voice` 枚举
  - 支持三字母/两字母声音 ID 格式的自动转换（如 "Serena" → `SERENA`）
  - 使用 `MultiModalConversation` 进行流式 API 调用
  - 支持 RxJava Flowable 处理流式响应
  - 音频数据 Base64 解码和回调
  - **智能文本分割**：将长文本按语义和标点分割为小 chunk
    - 优先级 1：句末标点（`。！？.!?`）
    - 优先级 2：句中停顿（`，、,;:：`）
    - 优先级 3：空格、换行符
    - 优先级 4：按长度强制截断（MAX_TEXT_LENGTH = 550）
  - **多 chunk 顺序处理**：单个 chunk 完成后自动处理下一个
  - **流式回调**：首个 chunk 开始时触发 `onSynthesisStarted()`
  - **正确完成通知**：所有 chunk 完成后才触发 `onSynthesisCompleted()`
  - **引擎特定语言转换**：`convertToQwenLanguageType()` 将 ISO 639 语言代码转换为通义千问 API 格式
    - 支持多种 ISO 639 代码格式（zh/zho/chi → Chinese, en/eng → English 等）
    - 无法识别的语言回退到默认 "Chinese"

**表现层（ui）** 负责用户界面呈现和交互：

| 组件 | 功能 |
|------|------|
| `MainScreen` | 主界面，整合所有组件，提供应用主入口 UI |
| `EngineSelector` | 引擎切换控件，SegmentedButton 风格，显示当前引擎并支持选择 |
| `VoicePreview` | 语音预览控件，文本输入 + 声音选择 + 播放控制 |
| `ConfigEditor` | 配置编辑表单，支持 API Key 输入和语音选择 |
| `ConfigBottomSheet` | 底部设置弹窗，包含引擎配置编辑表单 |
| `UpdateDialog` | 更新提示对话框，GitHub Releases 检查结果展示 |
| `PermissionDialog` | 权限请求对话框，联网权限请求 |
| `NotificationPermissionDialog` | 通知权限请求弹窗，Android 13+ POST_NOTIFICATIONS 权限 |
| `NetworkBlockedDialog` | 网络阻塞对话框，网络被阻止时提示用户 |
| `MarkdownText` | Markdown 文本组件，Release Notes 渲染支持 |
| `Theme` | 主题配置，Material 3 Expressive 主题定义 |
| `Color` | 颜色定义，应用色彩体系 |
| `Type` | 字体排版，文字样式和字号规范 |

## 配置存储架构

### 设计原则：分离全局配置与引擎特定配置

项目将配置分为两类，确保职责清晰：

| 配置类型 | 仓储接口 | 存储内容 | 存储文件 |
|---------|---------|---------|---------|
| 全局配置 | `AppConfigRepository` | 当前选择的引擎 | `talkify_app_config.xml` |
| 引擎配置 | `EngineConfigRepository` | apiKey、voiceId | `talkify_engine_configs.xml` |

### 为什么需要分离？

**问题场景**：如果"选择的引擎"存储在特定引擎的配置中
- ❌ 引擎配置仓储持有全局状态，职责不清
- ❌ 新引擎命名可能造成混淆
- ❌ 架构上不符合单一职责原则

**解决方案**：独立的全局配置仓储
- ✅ `AppConfigRepository` 专门管理全局状态
- ✅ `EngineConfigRepository` 只管引擎特定配置
- ✅ 新增引擎时，不会影响全局配置逻辑

### 引擎选择持久化流程

```
应用启动 → AppConfigRepository.getSelectedEngineId()
         ↓
    存在已保存ID → TtsEngineRegistry.getEngine() 获取引擎
         ↓ 不存在
    保存默认引擎ID → 使用默认引擎
```

## 代码规范

### KDoc 注释标准

项目要求所有公开 API 和关键组件添加 KDoc 注释，确保代码自文档化：

**接口类注释**：
```kotlin
/**
 * 引擎配置仓储接口
 *
 * 定义引擎配置存取的标准方法
 * 采用接口设计，解耦配置存储与业务逻辑
 * 支持多引擎配置隔离存储
 */
interface EngineConfigRepository
```

**数据类注释**：
```kotlin
/**
 * 配置项数据类
 *
 * @param key 配置项唯一标识
 * @param label 显示标签
 * @param value 当前值
 * @param isPassword 是否为密码输入模式
 * @param isVoiceSelector 是否为语音选择模式
 */
data class ConfigItem(...)
```

### 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 仓储实现 | `{引擎名称}VoiceRepository` | `Qwen3TtsVoiceRepository` |
| 仓储实现 | `{引擎名称}ConfigRepository` | `Qwen3TtsConfigRepository` |
| 仓储实现 | `SharedPreferencesAppConfigRepository` | 全局配置仓储 |
| 引擎 ID | 使用云服务官方产品标识符 | `qwen3-tts` |
| 引擎接口 | `{引擎名称}Engine` | `Qwen3TtsEngine` |
| 引擎工厂 | `TtsEngineFactory` | 引擎工厂单例 |
| TTS 服务 | `TalkifyTtsService` | TTS 服务实现 |

**命名原则**：使用具体引擎名称作为类名前缀，避免使用云服务商公司名称
- ✅ 正确：`Qwen3TtsVoiceRepository`
- ❌ 错误：`AlibabaCloudVoiceRepository`（公司名称，不够具体）

## 国际化

项目支持多语言，通过 Android 资源系统实现字符串外部化。

### 字符串资源文件

所有 UI 文本应定义在 `app/src/main/res/values/strings.xml`：

```xml
<!-- 通用 -->
<string name="settings">设置</string>
<string name="save">保存</string>
<string name="cancel">取消</string>

<!-- 主界面 -->
<string name="synthesis_engine">合成引擎</string>
<string name="provider_format">提供商: %1$s</string>

<!-- 语音预览 -->
<string name="voice_preview">语音预览</string>
<string name="input_text_label">输入要合成的文本</string>
<string name="play">播放</string>
<string name="stop">停止</string>

<!-- 配置编辑 -->
<string name="api_key_label">API Key</string>
<string name="save_config">保存配置</string>
```

### 添加新字符串的流程

1. 在 `strings.xml` 中添加新的字符串资源
2. 在 UI 组件中使用 `stringResource(R.string.字符串_id)` 引用
3. 添加其他语言版本（values-zh-rCN、values-en 等）

### 使用示例

```kotlin
@Composable
fun ExampleComponent() {
    Text(
        text = stringResource(R.string.settings),
        style = MaterialTheme.typography.titleMedium
    )
}
```

### Composable 上下文字符串使用

在 `remember` 或状态初始化块中使用字符串时，需先获取字符串：

```kotlin
// 正确：先获取字符串
@Composable
fun ExampleComponent() {
    val title = stringResource(R.string.title)
    var text by remember { mutableStateOf(title) }
    // ...
}

// 错误：Composable 调用不在 Composable 上下文中
@Composable
fun ExampleComponent() {
    var text by remember { mutableStateOf(stringResource(R.string.title)) } // 编译错误！
    // ...
}
```

### TTS 错误消息

TTS 服务使用统一的错误码体系，定义在 `TtsErrorCode`：

| 错误码 | 错误消息 |
|--------|----------|
| ERROR_NO_ENGINE | 未找到可用的 TTS 引擎 |
| ERROR_ENGINE_NOT_FOUND | 引擎不存在 |
| ERROR_ENGINE_NOT_CONFIGURED | 请先配置 API Key |
| ERROR_SYNTHESIS_FAILED | 语音合成失败 |
| ERROR_NETWORK_UNAVAILABLE | 网络不可用，请检查网络连接 |
| ERROR_INVALID_REQUEST | 无效的合成请求 |
| ERROR_ENGINE_INIT_FAILED | 引擎初始化失败 |
| ERROR_CONFIG_NOT_FOUND | 未找到引擎配置 |
| ERROR_UNKNOWN | 发生未知错误 |
| ERROR_NOT_IMPLEMENTED | 该引擎功能尚未实现 |

**用户提示配置建议**：`tts_config_suggestion` - "请前往应用设置页面配置 API Key"

**错误处理助手**：`TtsErrorHelper` 提供用户友好的 Toast 提示，包含 3 秒冷却机制避免重复提示。

## 资源文件

- `app/src/main/res/values/strings.xml`：UI 字符串资源（支持国际化）
- `app/src/main/res/values/bailian-Qwen3-TTS-voices.xml`：阿里云通义千问3引擎的声音配置
  - voice_ids：声音英文标识
  - display_names：中文显示名称
  - descriptions：声音特色描述
  - supported_languages：支持语言
  - supported_models：支持的模型版本
- `app/src/main/res/xml/tts_engine.xml`：TTS 服务元数据
  - 声明支持的语音语言（zh、en）
  - 系统通过此文件识别 TTS 引擎

### 声音配置 XML 结构示例

```xml
<resources>
    <voice>
        <voice_id>aitianhuaxiao</voice_id>
        <display_name>艾天华小</display_name>
        <description>童声，活泼可爱</description>
        <supported_languages>zh</supported_languages>
        <supported_models>qwen3-tts</supported_models>
    </voice>
    <!-- 更多声音配置... -->
</resources>
```

## 已实现功能

### 1. 引擎切换功能

- 显示当前选中的 TTS 引擎信息（名称和提供商）
- 点击弹出 Material 3 底部选择 Sheet
- 支持 SegmentedButton 风格的引擎选择
- 当前默认引擎：阿里云百炼"通义千问3语音合成"

### 2. 语音预览功能

**文本输入区域**：
- 多行文本输入框（3-5 行）
- 支持自定义标签和占位符
- 默认文本示例："你好，这是语音合成的测试文本。"

**声音选择区域**：
- 水平滚动列表展示可选声音
- 每个声音显示中文友好名称
- 选中状态有视觉反馈（高亮背景）
- 支持 48 种阿里云通义千问3引擎的声音
- 无可用声音时显示空状态提示

**播放控制区域**：
- 长条形 Pill Button 样式
- 播放状态：绿色主题，显示"播放"文字和播放图标
- 停止状态：红色主题，显示"停止"文字和停止图标
- 图标和文字并排显示，不再残缺

### 3. 动态声音加载

- 使用 `LaunchedEffect` 监听引擎变化
- 根据当前引擎动态加载对应的声音列表
- 自动选中保存的配置中指定的声音或第一个可用声音
- 加载过程中显示加载动画
- 接口设计便于后续扩展其他引擎服务

### 4. 引擎配置编辑与存储

**配置编辑**：
- 右下角悬浮按钮（FloatingActionButton）唤出底部设置弹窗
- API Key 输入框（密码模式隐藏输入）
- 声音选择下拉菜单（从引擎可用声音列表中选择）
- 修改状态追踪，仅在有修改时启用保存按钮
- 保存后自动关闭设置弹窗

**配置存储**：
- 引擎特定配置：使用 `EngineConfigRepository` 存储
  - 存储位置：`talkify_engine_configs.xml`
  - 配置内容：apiKey（API 密钥）、voiceId（默认声音 ID）
  - 按引擎 ID 隔离存储
  - 支持冷启动恢复
- 引擎选择：使用 `AppConfigRepository` 存储
  - 存储位置：`talkify_app_config.xml`
  - 配置内容：selected_engine（用户选择的引擎 ID）
  - 全局配置，独立于任何引擎

**交互优化**：
- 底部弹窗设计，比侧边抽屉更适合移动端
- 右下角悬浮按钮提供清晰的设置入口
- 点击外部区域或关闭按钮可关闭弹窗
- 保存成功后自动关闭

### 5. 引擎注册表

项目使用统一的引擎注册表管理所有可用引擎：

**注册表功能**：
- `TtsEngineRegistry.availableEngines`：获取所有可用引擎列表
- `TtsEngineRegistry.getEngine(id)`：根据 ID 获取引擎
- `TtsEngineRegistry.defaultEngine`：获取默认引擎
- `EngineIds.entries`：获取所有定义的引擎 ID

**新增引擎步骤**：
1. 在 `EngineIds` 密封类中添加新的引擎 ID 定义
2. 创建对应的 Repository 实现
3. 在对应的 Repository 实现中添加引擎特定逻辑
4. 在 `MainScreen` 中注入对应的 Repository 实现
5. 注册表自动识别新引擎，无需额外配置

### 6. 国际化支持

- 所有 UI 文本外部化到 `strings.xml`
- 支持中文（默认）和英文（可扩展）
- 统一的字符串使用规范
- 良好的空状态和加载状态处理

### 7. TTS 服务注册

**服务声明**：
- 在 `AndroidManifest.xml` 中声明 `TalkifyTtsService`
- 使用 `android.permission.BIND_TEXT_TO_SPEECH_SERVICE` 权限
- 通过 `android.intent.action.TTS_SERVICE` intent-filter 注册
- 提供 TTS 服务元数据 `tts_engine.xml`

**Activity 组件**：
- `MainActivity`：应用入口 Activity，Compose UI 启动点
- `TalkifyNotificationActivity`：全屏通知弹窗 Activity
  - 用于 heads-up 悬浮通知的全屏展示
  - 设置 FLAG_SHOW_WHEN_LOCKED、FLAG_TURN_SCREEN_ON 等窗口标志
  - 单顶栈模式（launchMode="singleTop"）
  - 排除在最近任务列表之外（excludeFromRecents="true"）
- `TalkifyCheckDataActivity`：TTS 数据检查 Activity
  - 用于系统 TTS 集成时的数据检查
  - 接收系统 TTS 引擎的回调请求
- `TalkifySampleTextActivity`：采样文本 Activity
  - 用于系统 TTS 引擎的采样文本展示
  - 接收系统 TTS 引擎的回调请求

**通知权限配置**：
- `POST_NOTIFICATIONS`：发送通知权限（Android 13+ 运行时权限）
- `USE_FULL_SCREEN_INTENT`：全屏 Intent 权限（用于 heads-up 悬浮通知）
- 通知通道在 `TalkifyApplication.onCreate()` 中预创建
- 系统通知通道 importance 为 `IMPORTANCE_HIGH`，支持悬浮弹窗

**通知系统设计**：
- `TalkifyNotificationChannel` 枚举定义通知通道
  - TTS_PLAYBACK：TTS 播放通知通道（importance=IMPORTANCE_LOW）
  - SYSTEM_NOTIFICATION：系统通知通道（importance=IMPORTANCE_HIGH）
- `NotificationHelper` 底层通知构建工具
  - `sendNotification()`：发送通知
  - `buildNotification()`：构建通知对象
  - 支持 pendingIntent、fullScreenIntent 等高级功能
- `TalkifyNotificationHelper` 快捷通知发送 Helper
  - `sendTtsPlaybackNotification()`：发送"Talkify 正在朗读"通知
  - `sendSystemNotification()`：发送系统通知（支持动态文本和可选通知 ID）
- `NotificationContent` 数据类封装通知内容（标题、正文、图标）
- `NotificationOptions` 数据类封装通知选项（优先级、分类、持续性等）

**元数据配置**：
- `app/src/main/res/xml/tts_engine.xml`

**引擎抽象层**：
- `TtsEngineApi` 接口定义引擎核心方法
- `AbstractTtsEngine` 提供共性功能默认实现
- `TtsEngineFactory` 工厂支持引擎热插拔
- 引擎实例持有配置（API Key、voiceId）

**服务启动流程**：
1. 系统调用 `onCreate()` 初始化
2. 通过 `AppConfigRepository` 获取用户选择的引擎 ID
3. 通过 `EngineConfigRepository` 获取引擎配置
4. 使用 `TtsEngineFactory` 创建对应的引擎实例
5. 收到合成请求时委托引擎执行实际合成

### 8. 日志与错误处理

**日志系统（TtsLogger）**：
- 统一的日志打印工具，支持多级别（Debug/Info/Warning/Error/Verbose）
- Debug 日志可通过 `setDebugEnabled()` 开关控制
- 支持延迟求值的日志消息（减少不必要的字符串拼接）
- 线程安全，使用 `@Volatile` 和 `synchronized`
- 在 Release 构建时可选择性禁用所有日志

**错误码体系（TtsErrorCode）**：
- 定义 10 种统一的错误类型
- 错误码到用户友好消息的映射
- 提供错误码到 Android TTS 错误码的转换（`toAndroidError()`）
- 便于统一处理和国际化

**错误处理助手（TtsErrorHelper）**：
- 提供用户友好的 Toast 错误提示
- 3 秒冷却机制避免重复提示相同错误
- 自动记录错误到日志
- 配置错误时提供操作建议

**TalkifyTtsService 错误处理**：
- 完善的空指针检查和异常处理
- 全面的日志记录（初始化、配置检查、合成流程）
- 硬编码提取为常量（采样率、音频格式、声道数）
- 引擎释放状态追踪，防止重复释放

**引擎抽象层增强**：
- `AbstractTtsEngine` 提供日志工具方法
- `checkNotReleased()` 防止已释放的引擎被使用
- `isConfigured()` 检查引擎是否已配置（API Key）
- `TtsEngineFactory` 线程安全设计

### 9. 流式音频合成引擎实现

**AudioConfig 引擎音频配置类**：
- 封装引擎特定的音频参数
- 支持不同引擎使用不同的采样率和音频格式
- 提供默认配置和引擎特定配置
- 示例配置：
  - 通义千问3 TTS：采样率 24000Hz、PCM_16BIT、单声道

**SynthesisParams 合成参数数据类**：
- 封装语音合成的可调参数
- `pitch`：音调，值域 [0.0, 2.0]
- `speechRate`：语速，值域 [0.0, 2.0]
- `volume`：音量，值域 [0.0, 1.0]
- `language`：原始语言代码（ISO 639），由调用方从 `SynthesisRequest` 提取
- 从 `SynthesisRequest` 提取参数传递给引擎
- **语言参数设计**：保留原始 ISO 639 代码，不做转换，由各引擎实现自己的转换逻辑

**Qwen3TtsEngine 通义千问3引擎完整实现**：
- 基于 DashScope SDK 的流式音频合成
- 北京地域 API 端点：`https://dashscope.aliyuncs.com/api/v1`
- 使用 `MultiModalConversation.streamCall()` 实现流式合成
- `Flowable<MultiModalConversationResult>` 响应式流处理
- `DisposableSubscriber` 订阅流式结果
- 音频数据提取：`MultiModalConversationResult.getOutput().audio`
- Base64 解码后传递给监听器
- 引擎状态管理：isReleased、isCancelled、hasCompleted
- **智能文本分割**：`splitTextIntoChunks()` 方法将长文本按语义和标点分割
  - 优先级 1：句末标点（`。！？.!?`）适合自然停顿
  - 优先级 2：句中停顿（`，、,;:：`）用于次级分割点
  - 优先级 3：空格、换行符作为备用分割位置
  - 优先级 4：按长度强制截断（MAX_TEXT_LENGTH = 550）
  - 支持中英文、全角半角标点符号
- **多 chunk 顺序处理**：`processNextChunk()` 递归处理多个文本块
  - 单个 chunk 完成后自动调用下一个
  - 首个 chunk 开始时触发 `onSynthesisStarted()`
  - 所有 chunk 完成后触发 `onSynthesisCompleted()`
  - 支持取消和停止操作
- **语言代码转换**：`convertToQwenLanguageType()` 将 ISO 639 代码转换为 API 格式
  - 输入：原始语言代码（zh, zho, chi, en, eng 等）
  - 输出：通义千问 API 语言类型（Chinese, English 等）
  - 不支持的语言回退到默认 "Chinese"
- 完善的错误处理：
  - `NoApiKeyException` → API Key 配置错误
  - `UploadFileException` → 上传文件失败
  - `ApiException` → API 调用失败
  - 其他异常 → 发生错误

### 10. 检查更新功能

**功能概述**：
- 应用启动时自动检查 GitHub Releases 是否有新版本
- 使用 GitHub REST API 获取最新 Release 信息
- 发现新版本时弹出 Material 3 更新提示对话框
- 支持显示 Release Notes 作为更新说明
- 点击"立即更新"跳转到 GitHub Releases 页面下载

**GitHub API 集成**：
- API 端点：`https://api.github.com/repos/LonePheasantWarrior/Talkify/releases/latest`
- 必要的请求头：
  - `Accept: application/vnd.github.v3+json`
  - `User-Agent: Talkify-Android-App`
- 超时设置：连接超时 10 秒，读取超时 10 秒

**UpdateCheckResult 密封类**：
```kotlin
sealed class UpdateCheckResult {
    data class UpdateAvailable(val updateInfo: UpdateInfo) : UpdateCheckResult()
    data object NoUpdateAvailable : UpdateCheckResult()
    data object NetworkTimeout : UpdateCheckResult()
    data class NetworkError(val message: String) : UpdateCheckResult()
    data class ServerError(val httpCode: Int) : UpdateCheckResult()
    data class ParseError(val message: String) : UpdateCheckResult()
}
```

**错误处理策略**：
- `NetworkTimeout`：国内网络可能无法访问 GitHub，静默放弃，不显示错误提示
- `NetworkError`：显示"网络连接失败，请检查网络设置"
- `ServerError`：显示"GitHub 服务暂时不可用，请稍后再试"
- `ParseError`：显示"检查更新失败"
- 404（无 Release）：视为无更新，静默处理

**执行流程**：
```
应用启动 → 权限检查 → 网络连通性检查 → 更新检查
                              ↓
                        网络可用 → 检查更新
                              ↓
                        网络不可用 → 跳过更新检查
```

**文件结构**：
```
├── domain/
│   └── model/
│       ├── UpdateInfo.kt              # 更新信息数据类
│       └── UpdateCheckResult.kt       # 检查结果密封类
├── infrastructure/
│   └── app/
│       └── update/
│           └── UpdateChecker.kt       # GitHub Releases API 调用
└── ui/
    └── components/
        └── UpdateDialog.kt            # Material 3 更新提示弹窗
```

**更新检查流程**：
1. 在 `MainActivity.checkNetworkStatus()` 网络检查通过后调用 `checkForUpdates()`
2. `UpdateChecker.checkForUpdates()` 在 IO 协程中执行网络请求
3. 根据返回的 `UpdateCheckResult` 类型进行不同处理：
   - `UpdateAvailable`：显示更新对话框
   - `NoUpdateAvailable` / `NetworkTimeout`：静默忽略
   - 其他错误：显示用户友好的错误提示

**Release Notes 展示**：
- 更新对话框支持滚动显示 Release Notes
- 最大高度限制为 120.dp
- 使用 `verticalScroll` 实现滚动

**TtsSynthesisListener 合成监听器接口**：
- `onSynthesisStarted()`：合成开始回调
- `onAudioAvailable()`：音频数据可用（流式传输）
- `onSynthesisCompleted()`：合成完成回调
- `onError()`：错误回调

**TtsStreamHandler 流式处理接口**：
- 定义流式音频处理的标准方法
- 支持扩展不同类型的流处理实现

### 10. 语音预览功能（DemoService）

**TalkifyTtsDemoService 独立 TTS 演示服务**：
- 用于语音预览功能的独立服务，不依赖 Android TTS 系统框架
- 调用用户选择的 TTS 引擎进行语音合成
- 使用 `AudioTrack` 本地播放流式音频
- 支持播放、停止、释放操作

**服务状态管理**：
- `STATE_IDLE`：空闲状态
- `STATE_PLAYING`：播放中
- `STATE_STOPPED`：已停止
- `STATE_ERROR`：错误状态
- 状态监听器回调：`setStateListener(listener)`

**AudioTrack 配置**：
- 播放模式：`MODE_STREAM`（流式播放）
- 音频属性：`USAGE_MEDIA`、`CONTENT_TYPE_SPEECH`
- 动态缓冲区大小调整
- 单声道/立体声自动适配

**配置实时更新机制**：
- `ConfigBottomSheet` 添加 `onConfigSaved` 回调参数
- 用户点击"保存配置"后立即通知调用方
- `MainScreen` 接收回调并重新加载配置
- 解决配置缓存问题，无需重启应用即可使用新配置

**使用流程**：
```
用户输入文本 → 选择音色 → 点击播放
    ↓
验证输入和配置
    ↓
demoService.speak(text, config, params)
    ↓
TtsEngineFactory 创建引擎
    ↓
引擎流式合成音频
    ↓
AudioTrack 实时播放
    ↓
播放完成/停止
```

### 11. 请求队列与速率控制

**问题背景**：
- 第三方 TTS 云服务通常有速率限制（RPS/RPM）
- Android TTS 框架可能在短时间内发送大量请求
- 直接处理会导致 "Requests rate limit exceeded" 错误

**请求队列机制**：
- 使用 `LinkedBlockingQueue<SynthesisRequestWrapper>` 暂存合成请求
- `onSynthesizeText()` 将请求加入队列后立即返回，不阻塞调用线程
- 后台处理器按顺序取出请求进行处理
- **非阻塞轮询**：使用 `poll(100ms)` 替代阻塞式 `take()`，避免停止时死锁
- **队列清理**：新请求到达时自动清空 `requestQueue`，确保只处理最新请求

**信号量同步**：
- 使用 `Semaphore(1)` 限制同时只能有1个合成请求
- 处理请求前获取信号量 `processingSemaphore.acquire()`
- 完成或错误时释放信号量 `processingSemaphore.release()`
- 确保请求按顺序处理，避免触发速率限制
- **信号量保护**：停止时检查 `availablePermits()`，未释放时强制释放

**协程支持**：
- 使用 `CoroutineScope(SupervisorJob() + Dispatchers.IO)` 管理异步任务
- 请求处理器在协程中运行，不会阻塞主线程
- 服务销毁时取消协程 `serviceScope.cancel()`

**优雅关闭**：
- 使用 `AtomicBoolean(isStopped)` 标记服务状态
- 服务销毁时设置停止标志
- 正在处理的请求完成后自动退出处理循环
- 清理引擎资源和信号量
- **停止回调**：`onStop()` 调用时清理队列并释放信号量
- **处理前检查**：`processRequestInternal()` 处理前检查 `isStopped` 状态

**工作流程**：
```
用户按下停止 → onStop() → 清空队列 + 释放信号量
    ↓
用户再次开始 → onSynthesizeText() → 清空旧队列 → 加入新请求
    ↓
后台处理器循环：
    - poll(100ms) 非阻塞获取请求
    - 检查服务状态 isStopped
    - 获取 processingSemaphore
    - 执行语音合成
    - 完成/错误时释放信号量
    ↓
处理下一个请求
```

**配置隔离**：
- 按引擎 ID 隔离存储不同引擎的配置
- API Key、voiceId 等敏感信息独立存储
- 防止配置混淆和数据泄露

### 12. 架构优化与近期修复

#### 12.1 EngineConfigRepository 接口优化

**问题背景**：
- 原接口直接依赖 `TtsEngine` 类型，导致领域层与表现层耦合
- 新增引擎时需要修改接口定义，不符合开闭原则

**解决方案**：
- 将接口方法参数从 `TtsEngine` 改为 `engineId: String`
- 降低模块间耦合，提高扩展性

**修改前后对比**：

```kotlin
// 修改前
interface EngineConfigRepository {
    fun getConfig(engine: TtsEngine): EngineConfig
    fun saveConfig(engine: TtsEngine, config: EngineConfig)
    fun hasConfig(engine: TtsEngine): Boolean
}

// 修改后
interface EngineConfigRepository {
    fun getConfig(engineId: String): EngineConfig
    fun saveConfig(engineId: String, config: EngineConfig)
    fun hasConfig(engineId: String): Boolean
}
```

**影响范围**：
- `Qwen3TtsConfigRepository` 实现已同步更新
- `ConfigBottomSheet` 调用点已更新为 `currentEngine.id`
- `MainScreen` 调用点已更新为 `currentEngine.id`
- `TalkifyTtsDemoService` 已移除硬编码音频配置，改为动态获取

#### 12.2 ConfigBottomSheet 动画修复

**问题描述**：
- 冷启动后首次打开底部弹窗时，动画异常
- 弹窗先跳跃到高于预期的位置，再迅速回落到正常高度

**问题根因**：
- `LaunchedEffect(Unit)` 在每次重组时无条件触发 `show()`
- 与 `isOpen` 状态不同步，导致动画冲突

**解决方案**：
- 移除冲突的 `LaunchedEffect(Unit)`
- 添加 `skipPartiallyExpanded = true` 参数

```kotlin
// 修改前
val sheetState = rememberModalBottomSheetState()

LaunchedEffect(isOpen) {
    if (!isOpen && sheetState.isVisible) {
        sheetState.hide()
    }
}

LaunchedEffect(Unit) {
    sheetState.show()  // 每次重组都会执行，导致动画冲突
}

// 修改后
val sheetState = rememberModalBottomSheetState(
    skipPartiallyExpanded = true
)

LaunchedEffect(isOpen) {
    if (!isOpen && sheetState.isVisible) {
        sheetState.hide()
    }
}
// 移除 LaunchedEffect(Unit)，让组件自行管理初始动画
```

**效果**：
- 弹窗现在直接从底部平滑展开到完整高度
- 冷启动和热启动的动画表现一致

#### 12.3 Material 3 弃用 API 修复

**修复项 1：ConfigEditor.menuAnchor()**

```kotlin
// 修改前
modifier = Modifier
    .fillMaxWidth()
    .menuAnchor()

// 修改后
import androidx.compose.material3.ExposedDropdownMenuAnchorType

modifier = Modifier
    .fillMaxWidth()
    .menuAnchor(ExposedDropdownMenuAnchorType.PrimaryNotEditable)
```

**修复项 2：MainScreen.largeTopAppBarColors()**

```kotlin
// 修改前
colors = TopAppBarDefaults.largeTopAppBarColors(
    containerColor = MaterialTheme.colorScheme.surface,
    scrolledContainerColor = MaterialTheme.colorScheme.surfaceContainer
)

// 修改后
colors = TopAppBarDefaults.topAppBarColors(
    containerColor = MaterialTheme.colorScheme.surface,
    scrolledContainerColor = MaterialTheme.colorScheme.surfaceContainer
)
```

**修复项 3：TalkifyTtsDemoService 硬编码配置**

```kotlin
// 修改前
private val audioConfig: AudioConfig = AudioConfig.QWEN3_TTS

// 修改后
val audioConfig = engine.getAudioConfig()
```

**构建结果**：
- 修复后项目编译通过，无警告和错误
- 使用最新的 Material 3 API，确保未来兼容性

### 13. 开发规范补充

#### 13.1 Compose UI 组件设计规范

**ModalBottomSheet 使用建议**：
- 使用 `skipPartiallyExpanded = true` 避免部分展开状态
- 避免在 `LaunchedEffect` 中同时控制 show/hide
- 让组件自行管理初始展开动画

**弃用 API 处理**：
- 定期检查编译日志中的弃用警告
- 优先使用新的 API 替代方案
- 确保使用最新的 Material 3 组件版本

**状态管理**：
- 复杂状态使用 `remember { mutableStateOf(...) }`
- 派生状态使用 `derivedStateOf` 计算
- 避免不必要的重组，使用正确的依赖键

### 14. 启动网络检查功能

#### 14.1 功能概述

应用启动时自动检查网络访问能力，确保 TTS 功能可用。检查流程：

```
应用启动 → 检查联网权限
    ↓ 无权限 → 弹窗提示，授权后跳转系统设置
    ↓ 有权限 → 检查网络可用性
        ↓ 无网络 → 弹窗提示，查看系统设置
        ↓ 网络可用 → 检查实际连接（TCP 测试）
            ↓ 连接失败 → 弹窗提示（可能是 Android 16 "允许网络访问" 开关关闭）
            ↓ 连接成功 → 正常启动应用
```

#### 14.2 权限检查模块

**PermissionChecker** (`infrastructure/app/permission/PermissionChecker.kt`)：
- `hasInternetPermission(context)`：检查 INTERNET 权限
- `getMissingPermissions(context)`：获取缺失的权限列表
- 使用 `ContextCompat.checkSelfPermission` 进行标准权限检查

#### 14.3 网络状态监控模块

**ConnectivityMonitor** (`infrastructure/app/permission/ConnectivityMonitor.kt`)：

`NetworkStatus` 数据类：
| 字段 | 含义 |
|------|------|
| `hasNetwork` | 系统检测到物理网络连接（WiFi/蜂窝等） |
| `hasInternetCapability` | 网络有 `NET_CAPABILITY_INTERNET` 能力 |
| `isValidated` | 网络已被系统验证可以访问互联网 |
| `isBlockedBySystem` | 网络存在但被 Android 16 开关阻止 |
| `transportTypes` | 网络传输类型列表（WIFI, CELLULAR, ETHERNET, VPN） |

核心方法：
- `getCurrentNetworkStatus(context)`：获取详细网络状态
- `canAccessInternet(context)`：检查是否可访问互联网
- `testConnection(host, port, timeoutMs)`：TCP 连接测试
- `observeNetworkStatus(context)`：监听网络状态变化（返回 Flow）

#### 14.4 统一入口模块

**NetworkConnectivityChecker** (`infrastructure/app/permission/NetworkConnectivityChecker.kt`)：
- `canAccessInternet(context)`：完整的网络访问能力检查（挂起函数）
- `getNetworkUnavailableReason(context)`：获取网络不可用的原因

`NetworkUnavailableReason` 枚举：
| 值 | 含义 |
|------|------|
| `NONE` | 网络可用 |
| `NO_PERMISSION` | 无联网权限 |
| `NO_NETWORK` | 无网络连接 |
| `BLOCKED_BY_SYSTEM` | 被 Android 16 "允许网络访问" 开关阻止 |
| `NO_INTERNET_ACCESS` | 网络存在但无法访问互联网 |

#### 14.5 MainActivity 集成

**检测流程**：
1. `onCreate()` 调用 `checkNetworkStatus()`
2. `onResume()` 再次检查（防止用户从设置页返回后跳过检查）
3. 使用 `activityScope` 协程作用域管理异步检查
4. 状态通过 `mutableStateOf` 传递给 Compose UI 显示加载状态

**用户交互**：
- 显示加载状态：`isCheckingNetwork` 控制 CircularProgressIndicator 显示
- 权限拒绝弹窗：不可关闭，强制用户授权或退出
- 网络阻塞弹窗：不可关闭，引导用户打开系统设置
- 设置返回后自动重新检查

**生命周期管理**：
- `isActivityDestroyed` 标志位防止 Activity 销毁后回调执行
- `isReturningFromSettings` 防止从设置返回时重复检查
- `hasShownNetworkBlockedDialog` 防止弹窗重复显示
- `onSaveInstanceState`/`onRestoreInstanceState` 保持弹窗状态

#### 14.6 字符串资源

```xml
<!-- 权限检查 -->
<string name="permission_required_title">权限请求</string>
<string name="permission_required_message">联网权限是本应用正常运行所必需的。请授予权限以继续使用应用。</string>
<string name="permission_grant">授予权限</string>
<string name="permission_exit">退出应用</string>
<string name="network_blocked_title">无法连接网络</string>
<string name="network_blocked_message">无法访问互联网，请检查网络设置后重试。</string>
<string name="network_open_settings">打开系统设置</string>
<string name="checking_network">正在检查网络连接…</string>
```

#### 14.7 设计决策

**为什么需要 TCP 连接测试？**
- Android 16 引入了系统级 "允许网络访问" 开关
- 即使权限和网络都正常，该开关关闭时也无法访问互联网
- `ConnectivityManager` 的 API 无法检测此状态
- 实际 TCP 连接测试是最可靠的方法

**测试主机选择**：
- 默认使用 `www.aliyun.com:443`
- 阿里云是中国区最稳定的公共服务之一
- HTTPS 443 端口广泛开放
- 易于后续配置更改（如需）

**超时配置**：
- 默认超时 3 秒，平衡用户体验和可靠性
- 可通过 `ConnectivityMonitor.testConnection()` 自定义

#### 14.8 目录结构

```
infrastructure/app/permission/
├── PermissionChecker.kt         # 权限检查工具类
├── NetworkConnectivityChecker.kt # 网络连通性检查工具类（统一入口）
└── ConnectivityMonitor.kt       # 网络状态监控器（新）
```

**文件职责**：
- `PermissionChecker`：仅负责权限检查，不涉及网络状态
- `ConnectivityMonitor`：仅负责网络状态检测，不涉及权限
- `NetworkConnectivityChecker`：整合两者，提供统一入口

### 15. 错误处理改进

#### 15.1 概述

为解决"应用异常时无提示"的问题，项目进行了全面的错误处理增强：

1. **扩展错误码体系**：增加通用错误和网络错误类型
2. **全局异常捕获**：未捕获的异常会显示崩溃对话框
3. **错误消息传递**：确保错误信息能从服务层传递到 UI 层

#### 15.2 扩展错误码体系

**TtsErrorCode.kt** 新增错误码：

| 错误码 | 常量名 | 含义 | 用户提示 |
|--------|--------|------|----------|
| 1100 | `ERROR_GENERIC` | 通用错误 | "操作失败，请稍后重试" |
| 1101 | `ERROR_NETWORK_TIMEOUT` | 网络超时 | "网络连接超时，请检查网络设置" |
| 1102 | `ERROR_API_RATE_LIMITED` | API 频率限制 | "请求过于频繁，请稍后重试" |
| 1103 | `ERROR_API_SERVER_ERROR` | 服务端错误 | "服务暂时不可用，请稍后重试" |
| 1104 | `ERROR_API_AUTH_FAILED` | 认证失败 | "认证失败，请检查 API Key 配置" |

**getSuggestion() 方法**：为每个错误码提供用户建议操作

```kotlin
fun getSuggestion(errorCode: Int): String {
    return when (errorCode) {
        ERROR_ENGINE_NOT_CONFIGURED, ERROR_API_AUTH_FAILED -> 
            "请前往应用设置页面配置正确的 API Key"
        ERROR_NETWORK_UNAVAILABLE, ERROR_NETWORK_TIMEOUT -> 
            "请检查网络连接后重试"
        ERROR_API_RATE_LIMITED -> 
            "请等待片刻后重试"
        ERROR_API_SERVER_ERROR -> 
            "请稍后重试，或联系服务提供商"
        else -> 
            "请稍后重试"
    }
}
```

#### 15.3 全局异常处理

**TalkifyApplication.kt**：

```kotlin
class TalkifyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        TalkifyAppHolder.setContext(this)
        TalkifyExceptionHandler.initialize()
    }
}
```

**GlobalException.kt** 包含两个关键组件：

1. **TalkifyExceptionHandler**：全局未捕获异常处理器
   - 在应用启动时注册为默认的 `Thread.UncaughtExceptionHandler`
   - 捕获未处理异常，显示崩溃对话框
   - 提供"重启应用"和"报告问题"两个选项
   - 自动传递异常信息给原处理器

2. **TalkifyAppHolder**：应用上下文持有者
   - 用于在异常处理时获取 Context
   - 解决 Application 类初始化时 Context 不可用的问题

**崩溃对话框**：

```xml
<string name="crash_dialog_title">应用发生错误</string>
<string name="crash_dialog_message">很抱歉，应用发生了意外错误。\n\n%1$s\n\n请选择操作：</string>
<string name="crash_dialog_restart">重启应用</string>
<string name="crash_dialog_report">报告问题</string>
```

#### 15.4 错误消息传递机制

**TalkifyTtsDemoService 状态监听**：

```kotlin
class TalkifyTtsDemoService(private val engineId: String) {
    
    private var stateListener: ((Int, String?) -> Unit)? = null
    
    fun setStateListener(listener: (Int, String?) -> Unit) {
        stateListener = listener
    }
    
    private fun onError(message: String) {
        lastErrorMessage = message
        currentState = STATE_ERROR
        notifyStateChange()
    }
    
    private fun notifyStateChange() {
        stateListener?.invoke(currentState, lastErrorMessage)
    }
}
```

**MainScreen 错误显示**：

```kotlin
DisposableEffect(currentEngine.id) {
    demoService.setStateListener { state, errorMessage ->
        when (state) {
            TalkifyTtsDemoService.STATE_ERROR -> {
                isPlaying = false
                val displayMessage = errorMessage ?: "播放失败，请检查配置"
                scope.launch {
                    snackbarHostState.showSnackbar(displayMessage)
                }
            }
        }
    }
    onDispose { }
}
```

#### 15.5 引擎层异常映射

**Qwen3TtsEngine 异常处理**：

引擎实现层将 SDK 异常映射为标准错误码：

```kotlin
private fun mapExceptionToErrorCode(e: Exception): Int {
    return when (e) {
        is TimeoutException -> TtsErrorCode.ERROR_NETWORK_TIMEOUT
        is IOException -> TtsErrorCode.ERROR_NETWORK_UNAVAILABLE
        is IllegalArgumentException -> TtsErrorCode.ERROR_INVALID_REQUEST
        else -> TtsErrorCode.ERROR_GENERIC
    }
}
```

**TalkifyTtsService 错误推断**：

从错误消息文本推断错误类型：

```kotlin
private fun inferErrorCodeFromMessage(errorMessage: String): Int {
    return when {
        errorMessage.contains("API Key", ignoreCase = true) ||
        errorMessage.contains("认证", ignoreCase = true) -> {
            TtsErrorCode.ERROR_API_AUTH_FAILED
        }
        errorMessage.contains("超时", ignoreCase = true) -> {
            TtsErrorCode.ERROR_NETWORK_TIMEOUT
        }
        errorMessage.contains("频率", ignoreCase = true) ||
        errorMessage.contains("rate limit", ignoreCase = true) -> {
            TtsErrorCode.ERROR_API_RATE_LIMITED
        }
        else -> TtsErrorCode.ERROR_SYNTHESIS_FAILED
    }
}
```

#### 15.6 目录结构

```
app/src/main/java/com/github/lonepheasantwarrior/talkify/
├── TalkifyApplication.kt           # Application 类，全局初始化入口
├── GlobalException.kt              # 全局异常处理器和应用上下文持有者
└── service/
    ├── TtsErrorCode.kt             # 错误码定义（已扩展）
    ├── TtsErrorHelper.kt           # 错误处理助手
    └── TalkifyTtsDemoService.kt    # 语音预览服务（错误状态监听）
```

#### 15.7 设计决策

**为什么需要全局异常处理器？**
- 应用崩溃时用户无法获得任何反馈
- 无法得知崩溃原因，难以定位问题
- 全局处理器可以在崩溃前显示友好提示

**为什么需要 TalkifyAppHolder？**
- Application.onCreate() 执行时无法直接显示 Dialog
- 需要在 Application 类外部保存 Context 引用
- 在异常发生时获取有效的 Context 显示对话框

**错误消息传递的设计原则**：
- 错误信息应该尽可能传递给用户
- 使用 Snackbar 显示非致命错误
- 使用 Dialog 显示致命错误
- 提供明确的操作建议引导用户解决问题

### 16. 兼容模式

#### 16.1 功能概述

兼容模式是专为阅读软件（如开源阅读 Legado）设计的同步播放模式，解决第三方阅读软件与 TTS 服务之间的兼容性问题。

**解决的问题**：
- 部分阅读软件不支持异步回调机制，需要 TTS 服务在音频播放完成后才返回
- 阅读软件可能连续发送多个合成请求，导致 API 速率限制
- 翻页时需要立即中断当前播放并响应新请求

**工作模式**：
- 开启时：语音合成和播放同步进行，音频播放完成后才返回结果
- 关闭时：原有异步模式，请求加入队列后立即返回

**配置入口**：设置底部弹窗中的"兼容模式"开关
- 默认开启状态
- 提供帮助说明弹窗解释用途

#### 16.2 核心组件

**CompatibilityModePlayer** (`service/CompatibilityModePlayer.kt`)：

| 组件 | 类型 | 说明 |
|------|------|------|
| `audioPlayer` | TalkifyAudioPlayer | 内置音频播放器实例 |
| `isStopped` | Volatile Boolean | 停止标志，用于中断检查 |

核心方法：

| 方法 | 说明 |
|------|------|
| `playAllAndWait(audioData: ByteArray): Boolean` | 播放音频并等待完成 |
| `stop()` | 标记停止，中断等待循环 |
| `release()` | 释放资源，重置状态 |
| `reset()` | 重置播放器状态 |

**TalkifyAudioPlayer** (`util/TalkifyAudioPlayer.kt`)：

内置音频播放器，支持流式播放和进度回调。

| 配置项 | 值 |
|--------|-----|
| 采样率 | 24000 Hz |
| 音频格式 | PCM_16BIT |
| 声道数 | 1（单声道） |

核心方法：

| 方法 | 说明 |
|------|------|
| `play(audioData: ByteArray): Boolean` | 开始播放音频 |
| `write(data: ByteArray): Int` | 写入音频数据（流式） |
| `stop()` | 停止播放 |
| `release()` | 释放资源 |
| `waitForPlaybackComplete(timeoutSeconds: Int, shouldStop: (() -> Boolean)?): Boolean` | 等待播放完成 |
| `setOnProgressListener(listener: (Int, Int) -> Unit)` | 设置进度回调 |
| `setOnPlaybackCompleteListener(listener: () -> Unit)` | 设置完成回调 |
| `setOnErrorListener(listener: (String) -> Unit)` | 设置错误回调 |

**配置持久化**：

使用 `AppConfigRepository` 存储兼容模式开关状态：

```kotlin
interface AppConfigRepository {
    suspend fun isCompatibilityModeEnabled(): Boolean
    suspend fun setCompatibilityModeEnabled(enabled: Boolean)
}
```

存储位置：`talkify_app_config.xml`
- 键：`compatibility_mode_enabled`
- 默认值：`true`（开启）

#### 16.3 工作原理

**正常模式（兼容模式关闭）**：

```
onSynthesizeText() → 加入请求队列 → 立即返回
    ↓
后台处理器从队列取出请求
    ↓
调用引擎合成音频
    ↓
通过 SynthesisCallback.audioAvailable() 实时传输音频
    ↓
发送完成信号 SynthesisCallback.done()
```

**兼容模式（兼容模式开启）**：

```
onSynthesizeText() → 检查配置
    ↓ 兼容模式开启
processRequestSynchronously() 同步处理
    ↓
创建 CompatibilityModePlayer 实例
    ↓
引擎合成音频 → player.playAllAndWait() 阻塞等待
    ↓
音频播放完成 / 中断 / 超时
    ↓
返回 SynthesisCallback.done() 或 error()
```

#### 16.4 请求中断处理

**翻页场景**：

阅读软件翻页时可能直接发送新请求而不调用 `onStop()`，兼容模式需要处理这种情况：

```kotlin
private fun processRequestSynchronously(request: SynthesisRequest, callback: SynthesisCallback) {
    // 新请求到来时，如果正在处理中，则停止当前播放
    if (isSynthesisInProgress.getAndSet(true)) {
        currentPlayer?.stop()
        synthesisLatch = null
    }
    
    // ... 执行合成和播放 ...
}
```

**onStop() 处理**：

```kotlin
override fun onStop() {
    isSynthesisInProgress.set(false)
    
    // 中断等待中的 synthesisLatch
    synthesisLatch?.countDown()
    synthesisLatch = null
    
    // 停止当前播放
    currentPlayer?.stop()
    currentPlayer = null
    
    // 清理队列
    requestQueue.clear()
    // 释放信号量
    if (processingSemaphore.availablePermits() == 0) {
        processingSemaphore.release()
    }
}
```

**中断检查机制**：

`TalkifyAudioPlayer.waitForPlaybackComplete()` 支持可中断的等待：

```kotlin
fun waitForPlaybackComplete(
    timeoutSeconds: Int = 60,
    shouldStop: (() -> Boolean)? = null
): Boolean {
    // ... 初始化代码 ...
    
    return try {
        while (isPlaying.get() && audioTrack != null) {
            // 检查中断标志
            if (shouldStop != null && shouldStop()) {
                isPlaying.set(false)
                isPlaybackStarted.set(false)
                return false
            }
            
            // ... 检查播放进度 ...
            
            Thread.sleep(PLAYBACK_COMPLETE_CHECK_INTERVAL_MS)
        }
        true
    } catch (e: InterruptedException) {
        Thread.currentThread().interrupt()
        false
    }
}
```

#### 16.5 设计决策

**为什么需要单独的 CompatibilityModePlayer？**

- 封装兼容模式的特殊行为（同步播放、等待完成）
- 与正常模式代码隔离，避免污染
- 便于维护和测试

**为什么使用 CountDownLatch？**

- 实现同步等待机制
- 支持中断（countDown 可被其他线程调用）
- 避免协程带来的复杂性

**为什么使用 AudioTrack 而非 MediaPlayer？**

- 更低的延迟，适合实时语音播放
- 更细粒度的控制（播放头位置查询）
- 支持流式写入，无需预加载完整音频

**为什么需要 isStopped 标志？**

- latch.countDown() 只能调用一次，但中断可能发生在播放等待的任意时刻
- isStopped 标志可在多个检查点生效
- 确保快速响应中断请求

#### 16.6 目录结构

```
app/src/main/java/com/github/lonepheasantwarrior/talkify/
├── service/
│   ├── TalkifyTtsService.kt           # TTS 服务（兼容模式逻辑）
│   ├── CompatibilityModePlayer.kt     # 兼容模式播放器（新增）
│   └── engine/
│       └── TtsEngineApi.kt            # 合成监听器接口
└── util/
    └── TalkifyAudioPlayer.kt          # 内置音频播放器（新增）

app/src/main/res/
└── values/
    └── strings.xml                    # 兼容模式字符串资源
```

#### 16.7 字符串资源

```xml
<!-- 兼容模式 -->
<string name="compatibility_mode">兼容模式</string>
<string name="compatibility_mode_description">同步播放模式，音频播放完成后再返回。适用于部分阅读软件。</string>
<string name="compatibility_mode_help_title">什么是兼容模式？</string>
<string name="compatibility_mode_help_message">兼容模式是一种同步播放模式。在这种模式下，语音合成和播放会同步进行，只有当音频播放完成后才会返回结果。\n\n此模式适用于部分阅读软件，这些软件可能不支持异步回调机制，需要 TTS 服务在播放完成后才返回。</string>
<string name="compatibility_mode_help_confirm">知道了</string>
```

#### 16.8 测试要点

**正常模式测试**：
- 语音预览功能正常播放
- 多个快速请求不会触发速率限制
- onStop/onDestroy 正确停止播放

**兼容模式测试**：
- 语音预览播放完成后才返回
- 翻页时立即响应新请求
- 翻页后不会卡住
- 没有音频"重影"（双重播放）

### 17. 通知权限请求功能

#### 17.1 功能概述

TTS 应用工作场景大多在后台运行，需要通过通知展示朗读状态。通知权限是 Android 13+ 的运行时权限，必须在用户主动打开应用时请求，否则可能永远无法获得授权。

**设计目标**：
- 用户首次启动应用时显示权限说明弹窗
- 提供"同意"和"以后再说"两个选项
- 选择"同意"则向系统请求通知权限
- 选择"以后再说"则持久化该选择，后续启动不再弹窗打扰
- 已授权用户无需再次请求

#### 17.2 检查流程

```
应用启动
    ↓
检查是否已有通知权限 → 有 → 直接跳过，不弹窗
    ↓ 无
检查用户是否选择过"以后再说" → 是 → 直接跳过，不弹窗
    ↓ 否
显示 NotificationPermissionDialog
    ↓
用户选择"同意" → 向系统请求 POST_NOTIFICATIONS 权限
用户选择"以后再说" → 持久化选择，下次启动不再弹窗
```

#### 17.3 核心组件

**PermissionChecker** (`infrastructure/app/permission/PermissionChecker.kt`)：

```kotlin
/**
 * 检查是否具有通知权限
 *
 * Android 13+ 需要 POST_NOTIFICATIONS 运行时权限
 * Android 12 及以下版本自动视为已授予
 */
fun hasNotificationPermission(context: Context): Boolean {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        val hasPermission = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.POST_NOTIFICATIONS
        ) == PackageManager.PERMISSION_GRANTED
        hasPermission
    } else {
        true
    }
}
```

**AppConfigRepository 接口扩展** (`domain/repository/AppConfigRepository.kt`)：

```kotlin
/**
 * 检查用户是否选择跳过通知权限请求
 */
fun hasSkippedNotificationPermission(): Boolean

/**
 * 保存用户对通知权限请求的选择
 *
 * @param skipped true 表示用户选择"以后再说"，不再弹窗请求
 */
fun setSkippedNotificationPermission(skipped: Boolean)
```

**SharedPreferencesAppConfigRepository 实现** (`infrastructure/app/repo/SharedPreferencesAppConfigRepository.kt`)：

```kotlin
override fun hasSkippedNotificationPermission(): Boolean {
    return sharedPreferences.getBoolean(KEY_SKIPPED_NOTIFICATION_PERMISSION, false)
}

override fun setSkippedNotificationPermission(skipped: Boolean) {
    sharedPreferences.edit {
        putBoolean(KEY_SKIPPED_NOTIFICATION_PERMISSION, skipped)
    }
}

companion object {
    private const val KEY_SKIPPED_NOTIFICATION_PERMISSION = "skipped_notification_permission"
}
```

**NotificationPermissionDialog** (`ui/components/NotificationPermissionDialog.kt`)：

遵循 Material 3 Expressive 设计规范的通知权限请求弹窗：

```kotlin
@Composable
fun NotificationPermissionDialog(
    onConfirm: () -> Unit,
    onDismiss: () -> Unit,
    modifier: Modifier = Modifier
) {
    AlertDialog(
        icon = {
            Icon(
                imageVector = Icons.Filled.Notifications,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary
            )
        },
        title = {
            Text(
                text = stringResource(R.string.notification_permission_title),
                style = MaterialTheme.typography.headlineSmall
            )
        },
        text = {
            Text(
                text = stringResource(R.string.notification_permission_message),
                style = MaterialTheme.typography.bodyMedium
            )
        },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text(stringResource(R.string.notification_permission_agree))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(R.string.notification_permission_ask_later))
            }
        }
    )
}
```

#### 17.4 MainActivity 集成

**检查入口** (`MainActivity.kt`)：

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // ... 其他初始化 ...
    checkNetworkStatus()
    checkNotificationPermission()
}

private fun checkNotificationPermission() {
    if (PermissionChecker.hasNotificationPermission(this)) {
        return // 已授权，无需弹窗
    }

    if (appConfigRepository.hasSkippedNotificationPermission()) {
        return // 用户之前选择跳过，不再弹窗
    }

    showNotificationPermissionDialog = true
}
```

**权限请求 Launcher**：

```kotlin
private val notificationPermissionLauncher: ActivityResultLauncher<String> =
    registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->
        TtsLogger.d(TAG) { "notificationPermissionLauncher: 权限结果 = $isGranted" }
    }
```

**UI 集成**：

```kotlin
setContent {
    TalkifyTheme {
        Surface(color = MaterialTheme.colorScheme.background) {
            MainScreen(...)

            if (showNotificationPermissionDialog) {
                NotificationPermissionDialog(
                    onConfirm = {
                        notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                        showNotificationPermissionDialog = false
                    },
                    onDismiss = {
                        appConfigRepository.setSkippedNotificationPermission(true)
                        showNotificationPermissionDialog = false
                    }
                )
            }
        }
    }
}
```

#### 17.5 字符串资源

```xml
<!-- 通知权限 -->
<string name="notification_permission_title">通知权限</string>
<string name="notification_permission_message">Talkify 是一款语音合成应用，工作时需要在后台显示朗读状态通知。授予通知权限后，您可以更好地了解应用运行状态。</string>
<string name="notification_permission_agree">同意</string>
<string name="notification_permission_ask_later">以后再说</string>
<string name="notification_permission_denied">未授予通知权限，部分功能可能受限</string>
```

#### 17.6 设计决策

**为什么需要在应用启动时请求？**

TTS 应用与其他应用不同：
- 主要工作场景在后台（被阅读软件调用）
- 用户不会每次使用时都主动打开应用
- 如果不在用户主动打开应用时请求，很可能永远无法获得通知权限
- 与网络权限类似，这是应用正常运行所必需的

**为什么需要"以后再说"选项？**

- 尊重用户选择，避免强制弹窗
- 首次使用时不熟悉应用，匆忙做决定可能不合理
- 后续如果需要，用户可以随时在系统设置中手动开启
- 持久化后不再打扰，避免用户体验下降

**与网络权限检查的区别**

| 维度 | 网络权限 | 通知权限 |
|------|----------|----------|
| 权限类型 | 普通权限（安装时授予） | 运行时权限（需用户授权） |
| 拒绝后果 | 应用完全无法联网 | 核心功能可用，仅无通知 |
| 请求时机 | 启动时必须检查 | 启动时说明，可选择跳过 |
| 用户选择 | 必须授权否则退出 | 可选择"以后再说" |

**Android 13 以下兼容**

- `Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU` 时自动跳过检查
- 旧版本 Android 不需要 POST_NOTIFICATIONS 权限
- 通知功能在旧版本上不受影响

#### 17.7 目录结构

```
app/src/main/java/com/github/lonepheasantwarrior/talkify/
├── MainActivity.kt                                 # 应用入口（集成通知权限检查）
├── domain/
│   └── repository/
│       └── AppConfigRepository.kt                  # 接口扩展（新增方法）
├── infrastructure/
│   ├── app/
│   │   ├── permission/
│   │   │   └── PermissionChecker.kt                # 权限检查（新增方法）
│   │   └── repo/
│   │       └── SharedPreferencesAppConfigRepository.kt # 实现扩展
│   └── engine/
│       └── repo/
│           └── Qwen3TtsConfigRepository.kt         # 引擎配置仓储
└── ui/
    └── components/
        └── NotificationPermissionDialog.kt         # 通知权限弹窗（新增）

app/src/main/res/
└── values/
    └── strings.xml                                 # 通知权限字符串资源（新增）
```

#### 17.8 测试要点

**权限检查测试**：
- Android 13+ 设备：未授权时显示弹窗，已授权时不显示
- Android 12 及以下设备：自动跳过检查，不显示弹窗
- 选择"以后再说"后，下次启动不再显示弹窗
- 手动授权后，重启应用不再显示弹窗

**用户选择测试**：
- 点击"同意"后正确向系统请求权限
- 用户拒绝系统权限对话框后，下次启动不再自动请求
- 用户可在系统设置中手动开启/关闭通知权限

**持久化测试**：
- 选择"以后再说"后，SharedPreferences 中正确保存状态
- 清除应用数据后重新测试，首次启动应显示弹窗
- 卸载重装后测试，首次启动应显示弹窗

